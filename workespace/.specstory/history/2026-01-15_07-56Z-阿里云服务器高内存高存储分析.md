<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session c12a16bd-1f36-45a0-b8c6-6ed6f9fa1d85 (2026-01-15 07:56Z) -->

# 阿里云服务器高内存高存储分析 (2026-01-15 07:56Z)

_**User (2026-01-15 07:55Z)**_

通过spss连接阿里云服务器，分析高内存和高存储的原因？

---

_**Agent (model composer-1, mode Agent)**_



---

检查工作空间结构，准备创建用于分析高内存和高存储的脚本。


---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "*.sh" • **0** result in **1** directory</summary>

Directory: **/Volumes/Lexar/git/07Docker/workespace** (0 file)

</details>
</tool-use>

---



---

创建用于分析高内存和高存储的脚本：


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Volumes/Lexar/git/07Docker/workespace/analyze_server.sh</summary>

**Chunk 1**
Lines added: 249, lines removed: 1

```diff
@@ -1,1 +1,249 @@
- 
+ #!/bin/bash
+ 
+ # 服务器资源分析脚本
+ # 用途：通过SSH连接阿里云服务器，分析高内存和高存储的原因
+ 
+ set -e
+ 
+ # 颜色定义
+ RED='\033[0;31m'
+ GREEN='\033[0;32m'
+ YELLOW='\033[1;33m'
+ BLUE='\033[0;34m'
+ NC='\033[0m' # No Color
+ 
+ # 配置变量（可通过环境变量或参数传入）
+ SERVER_HOST="${SERVER_HOST:-}"
+ SERVER_USER="${SERVER_USER:-root}"
+ SSH_KEY="${SSH_KEY:-}"
+ PORT="${PORT:-22}"
+ 
+ # 显示使用说明
+ show_usage() {
+     echo -e "${BLUE}使用方法:${NC}"
+     echo "  $0 [选项] &lt;服务器地址&gt;"
+     echo ""
+     echo -e "${BLUE}选项:${NC}"
+     echo "  -u, --user USER       SSH用户名 (默认: root)"
+     echo "  -p, --port PORT       SSH端口 (默认: 22)"
+     echo "  -k, --key KEY_PATH    SSH私钥路径"
+     echo "  -h, --help           显示帮助信息"
+     echo ""
+     echo -e "${BLUE}环境变量:${NC}"
+     echo "  SERVER_HOST          服务器地址"
+     echo "  SERVER_USER          SSH用户名"
+     echo "  SSH_KEY              SSH私钥路径"
+     echo "  PORT                 SSH端口"
+     echo ""
+     echo -e "${BLUE}示例:${NC}"
+     echo "  $0 192.168.1.100"
+     echo "  $0 -u ubuntu -k ~/.ssh/id_rsa 192.168.1.100"
+     echo "  SERVER_HOST=192.168.1.100 SERVER_USER=root $0"
+ }
+ 
+ # 解析参数
+ parse_args() {
+     while [[ $# -gt 0 ]]; do
+         case $1 in
+             -u|--user)
+                 SERVER_USER="$2"
+                 shift 2
+                 ;;
+             -p|--port)
+                 PORT="$2"
+                 shift 2
+                 ;;
+             -k|--key)
+                 SSH_KEY="$2"
+                 shift 2
+                 ;;
+             -h|--help)
+                 show_usage
+                 exit 0
+                 ;;
+             -*)
+                 echo -e "${RED}错误: 未知选项 $1${NC}"
+                 show_usage
+                 exit 1
+                 ;;
+             *)
+                 SERVER_HOST="$1"
+                 shift
+                 ;;
+         esac
+     done
+ 
+     if [[ -z "$SERVER_HOST" ]]; then
+         echo -e "${RED}错误: 请提供服务器地址${NC}"
+         show_usage
+         exit 1
+     fi
+ }
+ 
+ # 构建SSH命令
+ build_ssh_cmd() {
+     local cmd="$1"
+     local ssh_opts=""
+     
+     if [[ -n "$SSH_KEY" ]]; then
+         ssh_opts="-i $SSH_KEY"
+     fi
+     
+     echo "ssh $ssh_opts -p $PORT $SERVER_USER@$SERVER_HOST \"$cmd\""
+ }
+ 
+ # 执行远程命令
+ remote_exec() {
+     local cmd="$1"
+     local ssh_cmd=$(build_ssh_cmd "$cmd")
+     eval "$ssh_cmd"
+ }
+ 
+ # 打印分隔线
+ print_separator() {
+     echo -e "\n${BLUE}========================================${NC}"
+     echo -e "${BLUE}$1${NC}"
+     echo -e "${BLUE}========================================${NC}\n"
+ }
+ 
+ # 检查SSH连接
+ check_connection() {
+     print_separator "检查SSH连接"
+     echo -e "${YELLOW}正在连接到 $SERVER_USER@$SERVER_HOST:$PORT...${NC}"
+     
+     if remote_exec "echo '连接成功'" &gt; /dev/null 2&gt;&amp;1; then
+         echo -e "${GREEN}✓ SSH连接成功${NC}"
+     else
+         echo -e "${RED}✗ SSH连接失败，请检查：${NC}"
+         echo "  1. 服务器地址是否正确"
+         echo "  2. SSH密钥是否配置正确"
+         echo "  3. 网络是否可达"
+         echo "  4. 防火墙规则是否允许"
+         exit 1
+     fi
+ }
+ 
+ # 分析内存使用情况
+ analyze_memory() {
+     print_separator "内存使用分析"
+     
+     echo -e "${YELLOW}1. 总体内存使用情况:${NC}"
+     remote_exec "free -h"
+     
+     echo -e "\n${YELLOW}2. 内存使用率最高的10个进程:${NC}"
+     remote_exec "ps aux --sort=-%mem | head -11 | awk '{printf \"%-8s %6s %6s %10s %s\n\", \$1, \$2, \$3, \$4, \$11}' | column -t"
+     
+     echo -e "\n${YELLOW}3. 详细内存占用进程 (TOP 10):${NC}"
+     remote_exec "ps aux --sort=-%mem | head -11 | tail -10"
+     
+     echo -e "\n${YELLOW}4. 系统缓存和缓冲区:${NC}"
+     remote_exec "cat /proc/meminfo | grep -E 'MemTotal|MemFree|MemAvailable|Buffers|Cached|SwapTotal|SwapFree'"
+     
+     echo -e "\n${YELLOW}5. 内存使用趋势 (如果可用):${NC}"
+     remote_exec "if command -v vmstat &gt; /dev/null 2&gt;&amp;1; then vmstat -s | head -10; else echo 'vmstat未安装'; fi"
+ }
+ 
+ # 分析存储使用情况
+ analyze_storage() {
+     print_separator "存储使用分析"
+     
+     echo -e "${YELLOW}1. 磁盘使用情况:${NC}"
+     remote_exec "df -h"
+     
+     echo -e "\n${YELLOW}2. 根目录下各目录大小 (TOP 15):${NC}"
+     remote_exec "du -h --max-depth=1 / 2&gt;/dev/null | sort -hr | head -15"
+     
+     echo -e "\n${YELLOW}3. /var 目录详细分析:${NC}"
+     remote_exec "du -h --max-depth=2 /var 2&gt;/dev/null | sort -hr | head -10"
+     
+     echo -e "\n${YELLOW}4. /home 目录详细分析:${NC}"
+     remote_exec "if [ -d /home ]; then du -h --max-depth=2 /home 2&gt;/dev/null | sort -hr | head -10; else echo '/home 目录不存在'; fi"
+     
+     echo -e "\n${YELLOW}5. /tmp 目录大小:${NC}"
+     remote_exec "du -sh /tmp 2&gt;/dev/null || echo '/tmp 目录无法访问'"
+     
+     echo -e "\n${YELLOW}6. 大文件查找 (大于100MB):${NC}"
+     remote_exec "find / -type f -size +100M 2&gt;/dev/null | head -20 | xargs -I {} sh -c 'du -h \"{}\" 2&gt;/dev/null' | sort -hr"
+     
+     echo -e "\n${YELLOW}7. 日志文件大小分析:${NC}"
+     remote_exec "find /var/log -type f -size +10M 2&gt;/dev/null | xargs -I {} sh -c 'du -h \"{}\" 2&gt;/dev/null' | sort -hr | head -10"
+ }
+ 
+ # 分析Docker资源使用（如果存在）
+ analyze_docker() {
+     print_separator "Docker资源分析"
+     
+     if remote_exec "command -v docker &gt; /dev/null 2&gt;&amp;1" &gt; /dev/null 2&gt;&amp;1; then
+         echo -e "${YELLOW}1. Docker容器资源使用:${NC}"
+         remote_exec "docker stats --no-stream --format 'table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}'"
+         
+         echo -e "\n${YELLOW}2. Docker镜像占用空间:${NC}"
+         remote_exec "docker images --format 'table {{.Repository}}\t{{.Tag}}\t{{.Size}}' | head -10"
+         
+         echo -e "\n${YELLOW}3. Docker数据卷占用:${NC}"
+         remote_exec "docker system df -v"
+     else
+         echo -e "${YELLOW}Docker未安装或不可用${NC}"
+     fi
+ }
+ 
+ # 分析系统负载
+ analyze_load() {
+     print_separator "系统负载分析"
+     
+     echo -e "${YELLOW}1. 系统负载:${NC}"
+     remote_exec "uptime"
+     
+     echo -e "\n${YELLOW}2. CPU使用率最高的10个进程:${NC}"
+     remote_exec "ps aux --sort=-%cpu | head -11 | awk '{printf \"%-8s %6s %6s %10s %s\n\", \$1, \$2, \$3, \$4, \$11}' | column -t"
+     
+     echo -e "\n${YELLOW}3. I/O等待情况:${NC}"
+     remote_exec "iostat -x 1 2 2&gt;/dev/null || echo 'iostat未安装，使用top查看'"
+ }
+ 
+ # 生成诊断报告
+ generate_report() {
+     print_separator "诊断建议"
+     
+     echo -e "${YELLOW}基于以上分析，建议检查以下方面:${NC}"
+     echo ""
+     echo "1. 内存优化建议:"
+     echo "   - 检查占用内存最高的进程，确认是否为预期行为"
+     echo "   - 考虑增加swap空间（如果内存不足）"
+     echo "   - 清理不必要的缓存和缓冲区"
+     echo ""
+     echo "2. 存储优化建议:"
+     echo "   - 清理日志文件（/var/log）"
+     echo "   - 清理Docker未使用的镜像和容器"
+     echo "   - 检查大文件，确认是否可以删除或归档"
+     echo "   - 清理临时文件（/tmp）"
+     echo ""
+     echo "3. 常用清理命令（谨慎使用）:"
+     echo "   - 清理Docker: docker system prune -a --volumes"
+     echo "   - 清理日志: journalctl --vacuum-time=7d"
+     echo "   - 清理包缓存: apt-get clean 或 yum clean all"
+     echo ""
+ }
+ 
+ # 主函数
+ main() {
+     parse_args "$@"
+     
+     echo -e "${GREEN}========================================${NC}"
+     echo -e "${GREEN}  服务器资源分析工具${NC}"
+     echo -e "${GREEN}  目标服务器: $SERVER_USER@$SERVER_HOST:$PORT${NC}"
+     echo -e "${GREEN}========================================${NC}"
+     
+     check_connection
+     analyze_memory
+     analyze_storage
+     analyze_docker
+     analyze_load
+     generate_report
+     
+     echo -e "\n${GREEN}分析完成！${NC}"
+ }
+ 
+ # 执行主函数
+ main "$@"
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: chmod +x /Volumes/Lexar/git/07Docker/workespace/analyze_server.sh</summary>

```bash
chmod +x /Volumes/Lexar/git/07Docker/workespace/analyze_server.sh
```
</details>
</tool-use>

---



---

已创建服务器资源分析脚本。使用方法：

## 使用方法

**基本用法：**
```bash
./analyze_server.sh 你的服务器IP
```

**带参数：**
```bash
# 指定用户名和SSH密钥
./analyze_server.sh -u ubuntu -k ~/.ssh/id_rsa 192.168.1.100

# 指定端口
./analyze_server.sh -p 2222 192.168.1.100
```

**使用环境变量：**
```bash
export SERVER_HOST=192.168.1.100
export SERVER_USER=root
export SSH_KEY=~/.ssh/id_rsa
./analyze_server.sh
```

## 脚本功能

脚本会自动分析：

1. **内存使用**
   - 总体内存使用情况
   - 占用内存最高的进程（TOP 10）
   - 系统缓存和缓冲区

2. **存储使用**
   - 磁盘使用情况
   - 各目录大小分析
   - 大文件查找（>100MB）
   - 日志文件分析

3. **Docker资源**（如果安装了Docker）
   - 容器资源使用
   - 镜像占用空间
   - 数据卷占用

4. **系统负载**
   - CPU使用率
   - I/O等待情况

脚本会输出诊断报告和优化建议。运行后查看输出即可定位高内存和高存储的原因。

---

